<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DTF Gang Sheet Editor</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%;
    font-family: Arial, sans-serif;
    user-select: none;
  }
  #container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
  }
  #toolbar {
    background: #222;
    color: white;
    padding: 8px;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  #toolbar > * {
    cursor: pointer;
  }
  #canvasWrapper {
    flex: 1;
    overflow: auto;
    background: #f0f0f0;
    position: relative;
  }
  canvas {
    background: white;
    display: block;
    margin: 20px;
    box-shadow: 0 0 5px rgba(0,0,0,0.3);
    cursor: default;
  }
  .ruler {
    position: absolute;
    background: #ddd;
    font-size: 10px;
    color: #333;
    user-select: none;
  }
  #rulerX {
    top: 0; left: 40px; right: 0;
    height: 40px;
    border-bottom: 1px solid #bbb;
  }
  #rulerY {
    top: 40px; left: 0; bottom: 0;
    width: 40px;
    border-right: 1px solid #bbb;
  }
</style>
</head>
<body>
<div id="container">
  <div id="toolbar">
    <input type="file" id="fileInput" multiple accept="image/*" />
    <button id="deleteBtn" disabled>Delete Selected</button>
    <button id="clearBtn">Clear All</button>
    <button id="zoomInBtn">Zoom +</button>
    <button id="zoomOutBtn">Zoom -</button>
    <button id="exportBtn">Export PNG</button>
    <span style="margin-left:auto;">Use Shift to keep aspect ratio resizing. R to rotate 15Â°.</span>
  </div>
  <div id="canvasWrapper" tabindex="0" style="position: relative;">
    <canvas id="canvas" width="1200" height="900"></canvas>
    <canvas id="rulerX" class="ruler" width="1160" height="40"></canvas>
    <canvas id="rulerY" class="ruler" width="40" height="860"></canvas>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const rulerX = document.getElementById('rulerX');
  const rulerXCtx = rulerX.getContext('2d');
  const rulerY = document.getElementById('rulerY');
  const rulerYCtx = rulerY.getContext('2d');

  const fileInput = document.getElementById('fileInput');
  const deleteBtn = document.getElementById('deleteBtn');
  const clearBtn = document.getElementById('clearBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const exportBtn = document.getElementById('exportBtn');

  const canvasWrapper = document.getElementById('canvasWrapper');

  let images = []; // {img, x, y, width, height, rotation}
  let selectedIndices = [];
  let mode = null; // 'drag', 'rotate', 'resize', 'select'
  let dragStart = null;
  let dragImageOffsets = [];

  let rotatingIndex = null;
  let rotateStartAngle = 0;
  let rotateStartMouseAngle = 0;

  let resizingIndex = null;
  let currentResizeCorner = null; // 0-3 corners
  let resizeStartMouse = null;
  let resizeStartSize = null;
  let resizeStartPos = null;

  let isDraggingSelectionBox = false;
  let selectionBox = null; // {xStart, yStart, x, y, w, h}

  let zoom = 1;
  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;

  // Helpers
  function radToDeg(rad) { return rad * 180 / Math.PI; }
  function degToRad(deg) { return deg * Math.PI / 180; }

  // Clear canvas
  function clearCanvas(ctx, width, height) {
    ctx.clearRect(0, 0, width, height);
  }

  // Draw grid lines on rulers
  function drawRulers() {
    const step = 50;
    const zoomStep = step * zoom;

    // Clear rulers
    clearCanvas(rulerXCtx, rulerX.width, rulerX.height);
    clearCanvas(rulerYCtx, rulerY.width, rulerY.height);

    rulerXCtx.fillStyle = '#ddd';
    rulerYCtx.fillStyle = '#ddd';
    rulerXCtx.fillRect(0, 0, rulerX.width, rulerX.height);
    rulerYCtx.fillRect(0, 0, rulerY.width, rulerY.height);

    rulerXCtx.strokeStyle = '#999';
    rulerYCtx.strokeStyle = '#999';
    rulerXCtx.fillStyle = '#333';
    rulerYCtx.fillStyle = '#333';
    rulerXCtx.font = '10px Arial';
    rulerYCtx.font = '10px Arial';

    // X ruler ticks and labels
    for (let x = 0; x <= canvasWidth; x += step) {
      const px = x * zoom;
      if (px > rulerX.width) break;
      rulerXCtx.beginPath();
      rulerXCtx.moveTo(px + 0.5, 30);
      rulerXCtx.lineTo(px + 0.5, 40);
      rulerXCtx.stroke();
      rulerXCtx.fillText(x, px + 2, 20);
    }
    // Y ruler ticks and labels
    for (let y = 0; y <= canvasHeight; y += step) {
      const py = y * zoom;
      if (py > rulerY.height) break;
      rulerYCtx.beginPath();
      rulerYCtx.moveTo(30, py + 0.5);
      rulerYCtx.lineTo(40, py + 0.5);
      rulerYCtx.stroke();
      rulerYCtx.fillText(y, 2, py + 12);
    }
  }

  // Rect intersection helper (axis aligned)
  function rectsIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || 
             r2.x + r2.w < r1.x || 
             r2.y > r1.y + r1.h ||
             r2.y + r2.h < r1.y);
  }

  // Draw selection box (dashed)
  function drawSelectionBox(box) {
    if (!box) return;
    ctx.save();
    ctx.strokeStyle = 'rgba(0,0,255,0.7)';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 1;
    ctx.strokeRect(box.x, box.y, box.w, box.h);
    ctx.restore();
  }

  // Draw resize handles (corners)
  function drawResizeHandles(x, y, w, h) {
    const size = 10;
    ctx.fillStyle = '#0a84ff';
    // corners: TL, TR, BR, BL
    const corners = [
      [x, y],
      [x + w, y],
      [x + w, y + h],
      [x, y + h]
    ];
    corners.forEach(([cx, cy]) => {
      ctx.fillRect(cx - size/2, cy - size/2, size, size);
    });
  }

  // Draw rotate handle (circle above top-center)
  function drawRotateHandle(x, y, w) {
    const handleRadius = 8;
    const handleX = x + w/2;
    const handleY = y - 20;
    ctx.beginPath();
    ctx.fillStyle = '#0a84ff';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.arc(handleX, handleY, handleRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }

  // Check if point in rectangle
  function pointInRect(px, py, rx, ry, rw, rh) {
    return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
  }

  // Check if point in rotate handle area
  function pointInRotateHandle(px, py, x, y, w) {
    const handleX = x + w / 2;
    const handleY = y - 20;
    const dist = Math.sqrt((px - handleX)**2 + (py - handleY)**2);
    return dist <= 10;
  }

  // Get mouse position relative to canvas, accounting for zoom
  function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) / zoom,
      y: (evt.clientY - rect.top) / zoom
    };
  }

  // Draw all images, selection boxes, handles
  function redraw() {
    ctx.setTransform(1,0,0,1,0,0); // reset transform
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    ctx.scale(zoom, zoom);

    // Draw grid background (optional)
    const gridStep = 50;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1 / zoom;
    for(let x = 0; x <= canvasWidth; x += gridStep){
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvasHeight);
      ctx.stroke();
    }
    for(let y = 0; y <= canvasHeight; y += gridStep){
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvasWidth, y);
      ctx.stroke();
    }

    // Draw images
    images.forEach((imgObj, i) => {
      ctx.save();
      ctx.translate(imgObj.x + imgObj.width/2, imgObj.y + imgObj.height/2);
      ctx.rotate(degToRad(imgObj.rotation));
      ctx.drawImage(imgObj.img, -imgObj.width/2, -imgObj.height/2, imgObj.width, imgObj.height);
      ctx.restore();

      if(selectedIndices.includes(i)){
        // Draw bounding box and handles
        ctx.save();
        ctx.strokeStyle = '#0a84ff';
        ctx.lineWidth = 2 / zoom;
        ctx.setLineDash([6 / zoom, 4 / zoom]);
        ctx.beginPath();
        ctx.rect(imgObj.x, imgObj.y, imgObj.width, imgObj.height);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw resize handles
        drawResizeHandles(imgObj.x, imgObj.y, imgObj.width, imgObj.height);

        // Draw rotate handle
        drawRotateHandle(imgObj.x, imgObj.y, imgObj.width);
        ctx.restore();
      }
    });

    // Draw selection box if any
    if(selectionBox){
      drawSelectionBox(selectionBox);
    }
  }

  // Find image index at mouse pos (topmost)
  function findImageAt(x, y){
    // We iterate backward (topmost first)
    for(let i = images.length - 1; i >= 0; i--){
      const imgObj = images[i];
      // Transform point to image rotated space
      const cx = imgObj.x + imgObj.width/2;
      const cy = imgObj.y + imgObj.height/2;
      const angle = degToRad(-imgObj.rotation);
      // Translate point to origin
      let dx = x - cx;
      let dy = y - cy;
      // Rotate point by -angle
      const rx = dx * Math.cos(angle) - dy * Math.sin(angle);
      const ry = dx * Math.sin(angle) + dy * Math.cos(angle);
      // Check if inside image bounds
      if(rx >= -imgObj.width/2 && rx <= imgObj.width/2 &&
         ry >= -imgObj.height/2 && ry <= imgObj.height/2){
           return i;
      }
    }
    return -1;
  }

  // Check if point in resize handle, returns corner index or null
  function findResizeHandle(x, y, imgObj){
    const size = 10 / zoom;
    const corners = [
      [imgObj.x, imgObj.y],
      [imgObj.x + imgObj.width, imgObj.y],
      [imgObj.x + imgObj.width, imgObj.y + imgObj.height],
      [imgObj.x, imgObj.y + imgObj.height]
    ];
    for(let i = 0; i < corners.length; i++){
      const [cx, cy] = corners[i];
      if(Math.abs(x - cx) <= size && Math.abs(y - cy) <= size){
        return i;
      }
    }
    return null;
  }

  // Mouse event handlers
  canvas.addEventListener('mousedown', evt => {
    evt.preventDefault();
    const mouse = getMousePos(evt);
    const mx = mouse.x;
    const my = mouse.y;

    // Check if clicking on rotate handle for any selected image
    for(const idx of selectedIndices){
      const img = images[idx];
      if(pointInRotateHandle(mx, my, img.x, img.y, img.width)){
        mode = 'rotate';
        rotatingIndex = idx;
        const cx = img.x + img.width/2;
        const cy = img.y + img.height/2;
        rotateStartMouseAngle = Math.atan2(my - cy, mx - cx);
        rotateStartAngle = img.rotation;
        return;
      }
    }

    // Check if clicking on resize handle for any selected image
    for(const idx of selectedIndices){
      const img = images[idx];
      const corner = findResizeHandle(mx, my, img);
      if(corner !== null){
        mode = 'resize';
        resizingIndex = idx;
        currentResizeCorner = corner;
        resizeStartMouse = {x: mx, y: my};
        resizeStartSize = {w: img.width, h: img.height};
        resizeStartPos = {x: img.x, y: img.y};
        return;
      }
    }

    // Check if clicking on selected image for dragging
    const clickedImageIndex = findImageAt(mx, my);
    if(clickedImageIndex !== -1){
      if(!selectedIndices.includes(clickedImageIndex)){
        // Select only this image
        selectedIndices = [clickedImageIndex];
      }
      mode = 'drag';
      dragStart = {x: mx, y: my};
      dragImageOffsets = selectedIndices.map(i => {
        const img = images[i];
        return {dx: mx - img.x, dy: my - img.y};
      });
      redraw();
      return;
    }

    // Clicking empty space: start selection box
    mode = 'select';
    isDraggingSelectionBox = true;
    selectionBox = {xStart: mx, yStart: my, x: mx, y: my, w: 0, h: 0};
    selectedIndices = [];
    redraw();
  });

  canvas.addEventListener('mousemove', evt => {
    evt.preventDefault();
    if(!mode) return;

    const mouse = getMousePos(evt);
    const mx = mouse.x;
    const my = mouse.y;

    switch(mode){
      case 'drag': {
        if(!dragStart) break;
        const dx = mx - dragStart.x;
        const dy = my - dragStart.y;
        selectedIndices.forEach((i, idx) => {
          images[i].x = mx - dragImageOffsets[idx].dx;
          images[i].y = my - dragImageOffsets[idx].dy;
        });
        redraw();
        break;
      }
      case 'rotate': {
        if(rotatingIndex === null) break;
        const img = images[rotatingIndex];
        const cx = img.x + img.width/2;
        const cy = img.y + img.height/2;
        const angle = Math.atan2(my - cy, mx - cx);
        let deltaAngle = radToDeg(angle - rotateStartMouseAngle);
        let newRotation = rotateStartAngle + deltaAngle;
        // Snap to 15 degrees
        const snap = 15;
        newRotation = Math.round(newRotation / snap) * snap;
        img.rotation = ((newRotation % 360) + 360) % 360;
        redraw();
        break;
      }
      case 'resize': {
        if(resizingIndex === null || currentResizeCorner === null) break;
        const img = images[resizingIndex];
        const dx = mx - resizeStartMouse.x;
        const dy = my - resizeStartMouse.y;

        let newW = resizeStartSize.w;
        let newH = resizeStartSize.h;
        let newX = resizeStartPos.x;
        let newY = resizeStartPos.y;

        // We ignore rotation for resizing simplicity (rect only)

        switch(currentResizeCorner){
          case 0: // top-left
            newW = resizeStartSize.w - dx;
            newH = resizeStartSize.h - dy;
            newX = resizeStartPos.x + dx;
            newY = resizeStartPos.y + dy;
            break;
          case 1: // top-right
            newW = resizeStartSize.w + dx;
            newH = resizeStartSize.h - dy;
            newY = resizeStartPos.y + dy;
            break;
          case 2: // bottom-right
            newW = resizeStartSize.w + dx;
            newH = resizeStartSize.h + dy;
            break;
          case 3: // bottom-left
            newW = resizeStartSize.w - dx;
            newH = resizeStartSize.h + dy;
            newX = resizeStartPos.x + dx;
            break;
        }

        // Keep aspect ratio if Shift pressed
        if(evt.shiftKey){
          const ratio = resizeStartSize.w / resizeStartSize.h;
          if(newW / newH > ratio){
            newW = newH * ratio;
          } else {
            newH = newW / ratio;
          }
          // Adjust x/y for top-left or bottom-left corner
          if(currentResizeCorner === 0 || currentResizeCorner === 3){
            newX = resizeStartPos.x + (resizeStartSize.w - newW);
          }
          // Adjust y for top-left or top-right corner
          if(currentResizeCorner === 0 || currentResizeCorner === 1){
            newY = resizeStartPos.y + (resizeStartSize.h - newH);
          }
        }

        // Minimum size limit
        newW = Math.max(20, newW);
        newH = Math.max(20, newH);

        img.width = newW;
        img.height = newH;
        img.x = newX;
        img.y = newY;

        redraw();
        break;
      }
      case 'select': {
        if(!isDraggingSelectionBox || !selectionBox) break;
        selectionBox.x = Math.min(selectionBox.xStart, mx);
        selectionBox.y = Math.min(selectionBox.yStart, my);
        selectionBox.w = Math.abs(mx - selectionBox.xStart);
        selectionBox.h = Math.abs(my - selectionBox.yStart);

        // Select images inside selection box
        selectedIndices = [];
        images.forEach((imgObj, i) => {
          const imgRect = {x: imgObj.x, y: imgObj.y, w: imgObj.width, h: imgObj.height};
          const selRect = {x: selectionBox.x, y: selectionBox.y, w: selectionBox.w, h: selectionBox.h};
          if(rectsIntersect(imgRect, selRect)){
            selectedIndices.push(i);
          }
        });
        redraw();
        break;
      }
    }
  });

  canvas.addEventListener('mouseup', evt => {
    evt.preventDefault();
    mode = null;
    dragStart = null;
    rotatingIndex = null;
    resizingIndex = null;
    currentResizeCorner = null;
    isDraggingSelectionBox = false;
    selectionBox = null;
    redraw();
    updateDeleteButton();
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', evt => {
    if(evt.key === 'Delete' || evt.key === 'Backspace'){
      if(selectedIndices.length > 0){
        evt.preventDefault();
        deleteSelected();
      }
    }
    if(evt.key.toLowerCase() === 'r'){
      if(selectedIndices.length > 0){
        evt.preventDefault();
        selectedIndices.forEach(i => {
          images[i].rotation = (images[i].rotation + 15) % 360;
        });
        redraw();
      }
    }
  });

  // Update delete button enabled state
  function updateDeleteButton(){
    deleteBtn.disabled = selectedIndices.length === 0;
  }

  // Delete selected images
  function deleteSelected(){
    images = images.filter((_, i) => !selectedIndices.includes(i));
    selectedIndices = [];
    redraw();
    updateDeleteButton();
  }

  // Clear all images
  clearBtn.onclick = () => {
    if(confirm('Clear all images?')){
      images = [];
      selectedIndices = [];
      redraw();
      updateDeleteButton();
    }
  };

  deleteBtn.onclick = () => {
    deleteSelected();
  };

  // Zoom controls
  zoomInBtn.onclick = () => {
    zoom = Math.min(5, zoom + 0.1);
    updateZoom();
  };
  zoomOutBtn.onclick = () => {
    zoom = Math.max(0.1, zoom - 0.1);
    updateZoom();
  };

  function updateZoom(){
    canvas.style.width = canvasWidth * zoom + 'px';
    canvas.style.height = canvasHeight * zoom + 'px';

    rulerX.width = canvasWidth * zoom;
    rulerY.height = canvasHeight * zoom;

    rulerX.style.width = rulerX.width + 'px';
    rulerY.style.height = rulerY.height + 'px';

    drawRulers();
    redraw();
  }

  // Export full resolution PNG
  exportBtn.onclick = () => {
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = canvasWidth;
    exportCanvas.height = canvasHeight;
    const exportCtx = exportCanvas.getContext('2d');

    // White background
    exportCtx.fillStyle = 'white';
    exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

    // Draw images without zoom
    images.forEach(imgObj => {
      exportCtx.save();
      exportCtx.translate(imgObj.x + imgObj.width/2, imgObj.y + imgObj.height/2);
      exportCtx.rotate(degToRad(imgObj.rotation));
      exportCtx.drawImage(imgObj.img, -imgObj.width/2, -imgObj.height/2, imgObj.width, imgObj.height);
      exportCtx.restore();
    });

    exportCanvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'dtf_gang_sheet.png';
      a.click();
      URL.revokeObjectURL(url);
    }, 'image/png');
  };

  // Handle file input (multiple images)
  fileInput.addEventListener('change', e => {
    const files = e.target.files;
    if(!files.length) return;

    for(let file of files){
      if(!file.type.startsWith('image/')) continue;
      const img = new Image();
      const url = URL.createObjectURL(file);
      img.onload = () => {
        // Fit image to max size if too big
        let w = img.width;
        let h = img.height;
        const maxDim = 300;
        if(w > maxDim || h > maxDim){
          const scale = Math.min(maxDim / w, maxDim / h);
          w = w * scale;
          h = h * scale;
        }
        images.push({
          img: img,
          x: (canvasWidth - w)/2,
          y: (canvasHeight - h)/2,
          width: w,
          height: h,
          rotation: 0
        });
        redraw();
        URL.revokeObjectURL(url);
      };
      img.src = url;
    }
    e.target.value = ''; // reset input
  });

  // Initialize rulers and zoom
  updateZoom();
  updateDeleteButton();
})();
</script>

</body>
</html>
